pipeline {
    agent any

    environment {
        DOCKER_REGISTRY = '680833125636.dkr.ecr.us-east-1.amazonaws.com/gitea-app'
        IMAGE_NAME = 'gitea-app'
        AWS_REGION = 'us-east-1'
        SONAR_PROJECT_KEY = 'Abendgast_Gitea'
        SONAR_ORGANIZATION = 'abendgast'
    }

    options {
        timestamps()
        timeout(time: 20, unit: 'MINUTES')
        skipDefaultCheckout()
    }

    triggers {
        githubPush()
    }

    stages {
        stage('Checkout') {
            when {
                branch 'dev'
            }
            steps {
                checkout scm
                script {
                    echo "Building from dev branch"
                    echo "Commit: ${env.GIT_COMMIT}"

                    // ÐžÑ‚Ñ€Ð¸Ð¼ÑƒÑ”Ð¼Ð¾ ÑÐ¿Ð¸ÑÐ¾Ðº Ð·Ð¼Ñ–Ð½ÐµÐ½Ð¸Ñ… Ñ„Ð°Ð¹Ð»Ñ–Ð²
                    def changedFiles = sh(
                        script: '''
                            if [ "$GIT_PREVIOUS_COMMIT" != "" ] && [ "$GIT_PREVIOUS_COMMIT" != "$GIT_COMMIT" ]; then
                                git diff --name-only $GIT_PREVIOUS_COMMIT $GIT_COMMIT
                            else
                                git show --pretty="" --name-only HEAD
                            fi
                        ''',
                        returnStdout: true
                    ).trim()

                    env.CHANGED_FILES = changedFiles
                    echo "Changed files:\n${changedFiles}"

                    // ÐŸÐµÑ€ÐµÐ²Ñ–Ñ€ÑÑ”Ð¼Ð¾ Ñ‡Ð¸ Ñ” Go Ñ„Ð°Ð¹Ð»Ð¸ ÑÐµÑ€ÐµÐ´ Ð·Ð¼Ñ–Ð½ÐµÐ½Ð¸Ñ…
                    def hasGoFiles = sh(
                        script: 'echo "$CHANGED_FILES" | grep -E "\\.(go)$" || echo "false"',
                        returnStdout: true
                    ).trim()

                    env.HAS_GO_CHANGES = hasGoFiles != "false" ? "true" : "false"
                    echo "Has Go file changes: ${env.HAS_GO_CHANGES}"
                }
            }
        }

        stage('Setup Go Environment') {
            when {
                allOf {
                    branch 'dev'
                    environment name: 'HAS_GO_CHANGES', value: 'true'
                }
            }
            steps {
                sh '''

                    if [ -f "go.mod" ]; then
                        echo "Installing Go dependencies..."
                        go mod download
                        go mod tidy
                    else
                        echo "No go.mod found, skipping dependency installation"
                    fi
                '''
            }
        }

        stage('Run Tests') {
            when {
                allOf {
                    branch 'dev'
                    environment name: 'HAS_GO_CHANGES', value: 'true'
                }
            }
            steps {
                sh '''
                    echo "Running Go tests with coverage..."

                    # Ð—Ð°Ð¿ÑƒÑÐºÐ°Ñ”Ð¼Ð¾ Ñ‚ÐµÑÑ‚Ð¸ Ð· coverage
                    go test -v -coverprofile=coverage.out ./...

                    # ÐŸÐ¾ÐºÐ°Ð·ÑƒÑ”Ð¼Ð¾ coverage summary
                    if [ -f "coverage.out" ]; then
                        echo "Coverage summary:"
                        go tool cover -func=coverage.out
                    else
                        echo "No coverage file generated"
                    fi
                '''
            }
        }

        stage('SonarCloud Analysis') {
            when {
                allOf {
                    branch 'dev'
                    environment name: 'HAS_GO_CHANGES', value: 'true'
                }
            }
            steps {
                withSonarQubeEnv('SonarCloud') {
                    sh '''
                        echo "Preparing SonarCloud analysis..."

                        # Ð¡Ñ‚Ð²Ð¾Ñ€ÑŽÑ”Ð¼Ð¾ sonar-project.properties ÑÐºÑ‰Ð¾ Ð¹Ð¾Ð³Ð¾ Ð½ÐµÐ¼Ð°Ñ”
                        if [ ! -f "sonar-project.properties" ]; then
                            echo "Creating sonar-project.properties..."
                            cat > sonar-project.properties << EOF
sonar.projectKey=${SONAR_PROJECT_KEY}
sonar.organization=${SONAR_ORGANIZATION}
sonar.sources=.
sonar.exclusions=**/*_test.go,**/vendor/**,**/testdata/**,**/*.pb.go
sonar.tests=.
sonar.test.inclusions=**/*_test.go
sonar.go.coverage.reportPaths=coverage.out
sonar.sourceEncoding=UTF-8
EOF
                        fi

                        echo "Running SonarCloud analysis for branch: ${BRANCH_NAME}"

                        # Ð—Ð°Ð¿ÑƒÑÐºÐ°Ñ”Ð¼Ð¾ SonarCloud Ð°Ð½Ð°Ð»Ñ–Ð· Ð´Ð»Ñ dev Ð³Ñ–Ð»ÐºÐ¸ (long-lived branch)
                        sonar-scanner \
                            -Dsonar.projectKey=${SONAR_PROJECT_KEY} \
                            -Dsonar.organization=${SONAR_ORGANIZATION} \
                            -Dsonar.host.url=https://sonarcloud.io \
                            -Dsonar.login=${SONAR_TOKEN} \
                            -Dsonar.scm.revision=${GIT_COMMIT} \
                            -Dsonar.branch.name=${BRANCH_NAME} \
                            -Dsonar.go.coverage.reportPaths=coverage.out
                    '''
                }
            }
        }

        stage('Quality Gate') {
            when {
                allOf {
                    branch 'dev'
                    environment name: 'HAS_GO_CHANGES', value: 'true'
                }
            }
            steps {
                timeout(time: 5, unit: 'MINUTES') {
                    script {
                        echo "Waiting for SonarCloud Quality Gate result..."
                        def qg = waitForQualityGate()

                        if (qg.status != 'OK') {
                            echo "Quality Gate failed: ${qg.status}"
                            echo "Check SonarCloud dashboard for details: https://sonarcloud.io/project/overview?id=${env.SONAR_PROJECT_KEY}"
                            error "Pipeline aborted due to quality gate failure: ${qg.status}"
                        }

                        echo "âœ… Quality Gate passed successfully!"
                    }
                }
            }
        }

        stage('Build Docker Image') {
            when {
                branch 'dev'
            }
            steps {
                script {
                    def shortCommit = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
                    def timestamp = sh(script: "date '+%Y%m%d%H%M'", returnStdout: true).trim()

                    env.IMAGE_TAG = "dev-${timestamp}-${shortCommit}"

                    echo "Building Docker image..."
                    echo "Image name: ${env.IMAGE_NAME}:${env.IMAGE_TAG}"
                    echo "Registry: ${env.DOCKER_REGISTRY}:${env.IMAGE_TAG}"

                    sh """
                        docker build -t ${env.IMAGE_NAME}:${env.IMAGE_TAG} .
                        docker tag ${env.IMAGE_NAME}:${env.IMAGE_TAG} ${env.DOCKER_REGISTRY}:${env.IMAGE_TAG}
                    """

                    echo "âœ… Docker image built successfully"
                }
            }
        }

        stage('Push to ECR') {
            when {
                branch 'dev'
            }
            steps {
                withAWS(credentials: 'aws-credentials', region: "${env.AWS_REGION}") {
                    sh '''
                        echo "Logging into ECR..."
                        aws ecr get-login-password --region $AWS_REGION | \
                            docker login --username AWS --password-stdin $DOCKER_REGISTRY

                        echo "Pushing image to ECR..."
                        docker push $DOCKER_REGISTRY:$IMAGE_TAG

                        echo "âœ… Image pushed successfully: $DOCKER_REGISTRY:$IMAGE_TAG"
                    '''
                }
            }
        }

        stage('Cleanup') {
            when {
                branch 'dev'
            }
            steps {
                sh """
                    echo "Cleaning up local Docker images..."
                    docker rmi ${env.IMAGE_NAME}:${env.IMAGE_TAG} || true
                    docker rmi ${env.DOCKER_REGISTRY}:${env.IMAGE_TAG} || true

                    # ÐžÑ‡Ð¸Ñ‰ÑƒÑ”Ð¼Ð¾ Ñ‚ÐµÑÑ‚Ð¾Ð²Ñ– Ñ„Ð°Ð¹Ð»Ð¸
                    rm -f coverage.out || true

                    echo "âœ… Cleanup completed"
                """
            }
        }
    }

    post {
        success {
            script {
                if (env.BRANCH_NAME == 'dev') {
                    def message = "ðŸŽ‰ SUCCESS: Dev pipeline completed successfully"
                    message += "\nðŸ“¦ Image: ${env.DOCKER_REGISTRY}:${env.IMAGE_TAG}"

                    if (env.HAS_GO_CHANGES == 'true') {
                        message += "\nâœ… SonarCloud quality gate passed"
                        message += "\nðŸ” View analysis: https://sonarcloud.io/project/overview?id=${env.SONAR_PROJECT_KEY}"
                    } else {
                        message += "\nâ­ï¸ No Go files changed, SonarCloud analysis skipped"
                    }

                    echo message
                } else {
                    echo "â„¹ï¸ Skipped: Not dev branch"
                }
            }
        }

        failure {
            script {
                def message = "âŒ FAILURE: Dev pipeline failed"

                if (env.HAS_GO_CHANGES == 'true') {
                    message += "\nðŸ” Check SonarCloud quality gate: https://sonarcloud.io/project/overview?id=${env.SONAR_PROJECT_KEY}"
                    message += "\nðŸ“‹ Review test results and code quality issues"
                }

                echo message
            }
        }

        always {
            script {
                echo "ðŸ“Š Pipeline execution completed"
                echo "ðŸ• Duration: ${currentBuild.durationString}"

                // ÐŸÑƒÐ±Ð»Ñ–ÐºÑƒÑ”Ð¼Ð¾ test results ÑÐºÑ‰Ð¾ Ñ”
                if (fileExists('**/test-results.xml')) {
                    publishTestResults([
                        testResultsPattern: '**/test-results.xml',
                        allowEmptyResults: true
                    ])
                }

                // ÐžÑ‡Ð¸Ñ‰ÑƒÑ”Ð¼Ð¾ workspace Ð²Ñ–Ð´ Ñ‚Ð¸Ð¼Ñ‡Ð°ÑÐ¾Ð²Ð¸Ñ… Ñ„Ð°Ð¹Ð»Ñ–Ð²
                sh '''
                    rm -f sonar-project.properties || true
                    rm -f coverage.out || true
                '''
            }
        }
    }
}
