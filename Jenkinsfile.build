pipeline {
    agent any

    environment {
        DOCKER_REGISTRY = '680833125636.dkr.ecr.us-east-1.amazonaws.com/gitea-app'
        IMAGE_NAME = 'gitea-app'
        AWS_REGION = 'us-east-1'
        SONAR_PROJECT_KEY = 'Abendgast_Gitea'
        SONAR_ORGANIZATION = 'abendgast'
        PATH = "/usr/local/go/bin:${env.PATH}"
        // Додаємо Java 17 до PATH
        JAVA_HOME = '/usr/local/java17'
    }

    options {
        timestamps()
        timeout(time: 20, unit: 'MINUTES')
        skipDefaultCheckout()
    }

    triggers {
        githubPush()
    }

    stages {
        stage('Checkout') {
            when {
                branch 'dev'
            }
            steps {
                checkout scm
                script {
                    echo "Building from dev branch"
                    env.GIT_COMMIT = sh(script: 'git rev-parse HEAD', returnStdout: true).trim()
                    echo "Commit: ${env.GIT_COMMIT}"

                    def changedFiles = sh(
                        script: '''
                            if [ -n "$GIT_PREVIOUS_COMMIT" ]; then
                                git diff --name-only $GIT_PREVIOUS_COMMIT $GIT_COMMIT
                            else
                                git show --pretty="" --name-only HEAD
                            fi
                        ''',
                        returnStdout: true
                    ).trim()

                    env.CHANGED_FILES = changedFiles
                    echo "Changed files:\n${changedFiles}"

                    def hasGoFiles = changedFiles.contains('.go')
                    env.HAS_GO_CHANGES = hasGoFiles ? "true" : "false"
                    echo "Has Go file changes: ${env.HAS_GO_CHANGES}"
                }
            }
        }

        stage('Setup Java 17') {
            when {
                allOf {
                    branch 'dev'
                    environment name: 'HAS_GO_CHANGES', value: 'true'
                }
            }
            steps {
                sh '''
                    echo "Setting up Java 17 for SonarCloud..."

                    # Перевіряємо чи вже встановлена Java 17
                    if [ -d "/usr/local/java17" ] && /usr/local/java17/bin/java -version 2>&1 | grep -q "17\\."; then
                        echo "Java 17 already installed"
                    else
                        echo "Installing Java 17..."
                        cd /tmp

                        # Завантажуємо та встановлюємо OpenJDK 17
                        curl -L -o openjdk-17_linux-x64_bin.tar.gz https://download.java.net/java/GA/jdk17.0.2/dfd4a8d0985749f896bed50d7138ee7f/8/GPL/openjdk-17.0.2_linux-x64_bin.tar.gz

                        # Створюємо директорію та розпаковуємо
                        mkdir -p /usr/local/java17
                        tar --strip-components=1 -C /usr/local/java17 -xzf openjdk-17_linux-x64_bin.tar.gz

                        # Очищуємо
                        rm -f openjdk-17_linux-x64_bin.tar.gz

                        echo "Java 17 installed successfully"
                    fi

                    # Перевіряємо версію
                    /usr/local/java17/bin/java -version

                    # Експортуємо JAVA_HOME для поточної сесії
                    export JAVA_HOME=/usr/local/java17
                    export PATH=$JAVA_HOME/bin:$PATH
                '''
            }
        }

        stage('Setup Go Environment') {
            when {
                allOf {
                    branch 'dev'
                    environment name: 'HAS_GO_CHANGES', value: 'true'
                }
            }
            steps {
                sh '''
                    if ! command -v go &> /dev/null; then
                        echo "Installing Go..."
                        (
                            cd /tmp
                            curl -L -o go1.21.5.linux-amd64.tar.gz https://go.dev/dl/go1.21.5.linux-amd64.tar.gz
                            tar -C /usr/local -xzf go1.21.5.linux-amd64.tar.gz
                            rm go1.21.5.linux-amd64.tar.gz
                        )
                        echo "Go installed successfully"
                    else
                        echo "Go already installed"
                    fi

                    go version

                    if [ ! -f "go.mod" ]; then
                        echo "Initializing Go module..."
                        go mod init gitea-app
                    fi

                    echo "Installing Go dependencies..."
                    go mod download || echo "No dependencies to download"
                    go mod tidy || echo "Module tidy completed"
                '''
            }
        }

        stage('Run Tests') {
            when {
                allOf {
                    branch 'dev'
                    environment name: 'HAS_GO_CHANGES', value: 'true'
                }
            }
            steps {
                sh '''
                    echo "Running Go tests for changed files..."

                    changed_packages=""
                    for file in $CHANGED_FILES; do
                        if echo "$file" | grep -E "\\.(go)$" > /dev/null; then
                            package_dir=$(dirname "$file")
                            if [ "$package_dir" = "." ]; then
                                package_dir="./"
                            else
                                package_dir="./$package_dir"
                            fi
                            changed_packages="$changed_packages $package_dir"
                        fi
                    done

                    if [ -n "$changed_packages" ]; then
                        unique_packages=$(echo $changed_packages | tr ' ' '\\n' | sort -u | tr '\\n' ' ')
                        echo "Testing packages: $unique_packages"

                        export GITEA_CONF=""
                        export USER=gitea
                        export HOME=/tmp/gitea-home
                        mkdir -p $HOME

                        for package in $unique_packages; do
                            echo "Testing package: $package"
                            if go test -v "$package" 2>/dev/null; then
                                echo "Tests passed for package: $package"
                            else
                                echo "No tests found or tests failed for package: $package, continuing..."
                            fi
                        done
                    else
                        echo "No Go packages to test"
                    fi
                '''
            }
        }

        stage('SonarCloud Analysis') {
            when {
                allOf {
                    branch 'dev'
                    environment name: 'HAS_GO_CHANGES', value: 'true'
                }
            }
            steps {
                withCredentials([string(credentialsId: 'sonar-token', variable: 'SONAR_TOKEN')]) {
                    sh '''
                        echo "Setting up SonarScanner with Java 17..."

                        # Встановлюємо JAVA_HOME і PATH для Java 17
                        export JAVA_HOME=/usr/local/java17
                        export PATH=$JAVA_HOME/bin:$PATH

                        # Перевіряємо версію Java
                        echo "Using Java version:"
                        java -version

                        # Видаляємо старі версії SonarScanner
                        rm -rf /usr/local/sonar-scanner /usr/local/bin/sonar-scanner || true
                        rm -rf /tmp/sonar-scanner* || true

                        echo "Installing latest SonarScanner compatible with Java 17..."
                        (
                            cd /tmp
                            # Використовуємо найновішу версію SonarScanner (5.x)
                            curl -L -o sonar-scanner-cli.zip https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-5.0.1.3006-linux.zip
                            unzip -o sonar-scanner-cli.zip
                            mv sonar-scanner-5.0.1.3006-linux /usr/local/sonar-scanner
                            ln -sf /usr/local/sonar-scanner/bin/sonar-scanner /usr/local/bin/sonar-scanner
                            chmod +x /usr/local/bin/sonar-scanner
                            rm -f sonar-scanner-cli.zip
                        )
                        echo "SonarScanner installed successfully"

                        echo "Preparing SonarCloud analysis..."

                        if [ ! -f "sonar-project.properties" ]; then
                            echo "Creating sonar-project.properties..."
                            cat > sonar-project.properties << EOF
sonar.projectKey=${SONAR_PROJECT_KEY}
sonar.organization=${SONAR_ORGANIZATION}
sonar.sources=.
sonar.exclusions=**/*_test.go,**/vendor/**,**/testdata/**,**/*.pb.go,Jenkinsfile*
sonar.tests=.
sonar.test.inclusions=**/*_test.go
sonar.go.coverage.reportPaths=coverage.out
sonar.sourceEncoding=UTF-8
EOF
                        fi

                        echo "Running SonarCloud analysis for branch: ${BRANCH_NAME}"
                        echo "Using Java: $JAVA_HOME"
                        echo "Token length: ${#SONAR_TOKEN}"

                        # Запускаємо SonarScanner з правильним JAVA_HOME
                        JAVA_HOME=/usr/local/java17 PATH=/usr/local/java17/bin:$PATH /usr/local/bin/sonar-scanner \
                            -Dsonar.projectKey=${SONAR_PROJECT_KEY} \
                            -Dsonar.organization=${SONAR_ORGANIZATION} \
                            -Dsonar.host.url=https://sonarcloud.io \
                            -Dsonar.token=${SONAR_TOKEN} \
                            -Dsonar.scm.revision=${GIT_COMMIT} \
                            -Dsonar.branch.name=${BRANCH_NAME} \
                            -Dsonar.go.coverage.reportPaths=coverage.out \
                            -Dsonar.java.binaries=. \
                            -Dsonar.analysis.mode=publish || echo "SonarCloud analysis completed with warnings"
                    '''
                }
            }
        }

        stage('Quality Gate') {
            when {
                allOf {
                    branch 'dev'
                    environment name: 'HAS_GO_CHANGES', value: 'true'
                }
            }
            steps {
                timeout(time: 5, unit: 'MINUTES') {
                    script {
                        try {
                            echo "Waiting for SonarCloud Quality Gate result..."
                            def qg = waitForQualityGate()

                            if (qg.status != 'OK') {
                                echo "Quality Gate failed: ${qg.status}"
                                echo "Check SonarCloud dashboard for details: https://sonarcloud.io/project/overview?id=${env.SONAR_PROJECT_KEY}"
                                currentBuild.result = 'UNSTABLE'
                            } else {
                                echo "Quality Gate passed successfully!"
                            }
                        } catch (Exception e) {
                            echo "Quality Gate check failed: ${e.getMessage()}"
                            echo "Continuing with build..."
                            currentBuild.result = 'UNSTABLE'
                        }
                    }
                }
            }
        }

        stage('Build Docker Image') {
            when {
                branch 'dev'
            }
            steps {
                script {
                    def shortCommit = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
                    def timestamp = sh(script: "date '+%Y%m%d%H%M'", returnStdout: true).trim()

                    env.IMAGE_TAG = "dev-${timestamp}-${shortCommit}"

                    echo "Building Docker image..."
                    echo "Image name: ${env.IMAGE_NAME}:${env.IMAGE_TAG}"
                    echo "Registry: ${env.DOCKER_REGISTRY}:${env.IMAGE_TAG}"

                    sh """
                        docker build -t ${env.IMAGE_NAME}:${env.IMAGE_TAG} .
                        docker tag ${env.IMAGE_NAME}:${env.IMAGE_TAG} ${env.DOCKER_REGISTRY}:${env.IMAGE_TAG}
                    """

                    echo "Docker image built successfully"
                }
            }
        }

        stage('Push to ECR') {
            when {
                branch 'dev'
            }
            steps {
                withAWS(credentials: 'aws-credentials', region: "${env.AWS_REGION}") {
                    sh '''
                        echo "Logging into ECR..."
                        aws ecr get-login-password --region $AWS_REGION | \
                            docker login --username AWS --password-stdin $DOCKER_REGISTRY

                        echo "Pushing image to ECR..."
                        docker push $DOCKER_REGISTRY:$IMAGE_TAG

                        echo "Image pushed successfully: $DOCKER_REGISTRY:$IMAGE_TAG"
                    '''
                }
            }
        }

        stage('Cleanup') {
            when {
                branch 'dev'
            }
            steps {
                sh """
                    echo "Cleaning up local Docker images..."
                    docker rmi ${env.IMAGE_NAME}:${env.IMAGE_TAG} || true
                    docker rmi ${env.DOCKER_REGISTRY}:${env.IMAGE_TAG} || true

                    rm -f coverage.out || true

                    echo "Cleanup completed"
                """
            }
        }
    }

    post {
        success {
            script {
                if (env.BRANCH_NAME == 'dev') {
                    def message = "SUCCESS: Dev pipeline completed successfully"
                    message += "\nImage: ${env.DOCKER_REGISTRY}:${env.IMAGE_TAG}"

                    if (env.HAS_GO_CHANGES == 'true') {
                        message += "\nSonarCloud analysis completed"
                        message += "\nView analysis: https://sonarcloud.io/project/overview?id=${env.SONAR_PROJECT_KEY}"
                    } else {
                        message += "\nNo Go files changed, SonarCloud analysis skipped"
                    }

                    echo message
                } else {
                    echo "Skipped: Not dev branch"
                }
            }
        }

        failure {
            script {
                def message = "FAILURE: Dev pipeline failed"

                if (env.HAS_GO_CHANGES == 'true') {
                    message += "\nCheck SonarCloud quality gate: https://sonarcloud.io/project/overview?id=${env.SONAR_PROJECT_KEY}"
                    message += "\nReview test results and code quality issues"
                }

                echo message
            }
        }

        unstable {
            script {
                def message = "UNSTABLE: Dev pipeline completed with warnings"
                message += "\nImage: ${env.DOCKER_REGISTRY}:${env.IMAGE_TAG}"
                message += "\nCheck SonarCloud for quality gate issues: https://sonarcloud.io/project/overview?id=${env.SONAR_PROJECT_KEY}"
                echo message
            }
        }

        always {
            script {
                echo "Pipeline execution completed"
                echo "Duration: ${currentBuild.durationString}"

                if (fileExists('**/test-results.xml')) {
                    publishTestResults([
                        testResultsPattern: '**/test-results.xml',
                        allowEmptyResults: true
                    ])
                }

                sh '''
                    rm -f sonar-project.properties || true
                    rm -f coverage.out || true
                '''
            }
        }
    }
}
