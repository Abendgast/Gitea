pipeline {
  agent {
    label 'docker-agent'
  }

  environment {
    SONAR_HOST_URL = 'http://sonarqube:9000'
    SONAR_SCANNER_OPTS = "-Xmx512m"
    JAVA_HOME = '/opt/java/openjdk'
  }

  options {
    skipDefaultCheckout true
    timeout(time: 45, unit: 'MINUTES')
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
        script {
          echo "Detected branch: ${env.BRANCH_NAME}"
          if (env.BRANCH_NAME != 'dev') {
            currentBuild.result = 'NOT_BUILT'
            error("Skipping analysis: not running on 'dev' branch.")
          }
        }
      }
    }

    stage('Detect Changes') {
      steps {
        script {
          sh "git fetch origin main"

          def changedGo = sh(script: '''
            git diff --name-only origin/main...HEAD | grep '\\.go$' || true
          ''', returnStdout: true).trim()

          def changedFiles = sh(script: '''
            git diff --name-only origin/main...HEAD | grep -E '\\.(go|js|ts|py|java|json|yaml|yml)$' || true
          ''', returnStdout: true).trim()

          if (changedGo) {
            writeFile file: 'changed-go-files.txt', text: changedGo
            echo "Detected changed .go files:\n${changedGo}"
            env.HAS_GO_CHANGES = "true"
          } else {
            echo "No .go files changed. Skipping SonarQube analysis."
          }

          if (changedFiles) {
            writeFile file: 'changed-files.txt', text: changedFiles
            echo "Detected changed files for security scan:\n${changedFiles}"
            env.HAS_FILE_CHANGES = "true"
          } else {
            echo "No relevant files changed. Skipping security scan."
          }

          if (!changedGo && !changedFiles) {
            currentBuild.result = 'SUCCESS'
            return
          }
        }
      }
    }

    stage('Snyk Security Scan') {
      when {
        environment name: 'HAS_FILE_CHANGES', value: 'true'
      }
      steps {
        script {
          withCredentials([
            string(credentialsId: 'snyk-api-token', variable: 'SNYK_TOKEN')
          ]) {
            try {
              sh '''
                echo "=== Running Snyk Security Scan ==="
                export SNYK_TOKEN=$SNYK_TOKEN

                snyk auth $SNYK_TOKEN

                mkdir -p snyk-results

                echo "Scanning dependencies..."
                snyk test --json > snyk-results/dependencies.json || true

                echo "Scanning code vulnerabilities..."
                if [ -f changed-files.txt ]; then
                  while IFS= read -r file; do
                    if [ -f "$file" ]; then
                      echo "Scanning: $file"
                      snyk code test "$file" --json >> snyk-results/code-scan.json || true
                    fi
                  done < changed-files.txt
                fi

                echo "Generating security report..."
                python3 -c "
import json
import os
import requests
from datetime import datetime

def send_discord_notification(message):
    webhook_url = 'https://discord.com/api/webhooks/1380213384561033216/iAk9OOjKtAtovX9RKPKM69qTMERc9c_dV0vk-5rzm2KvMDi2hAbKcBcHiL4H1mOzuVcD'
    data = {
        'content': message,
        'username': 'Snyk Security Bot'
    }
    try:
        response = requests.post(webhook_url, json=data)
        if response.status_code == 204:
            print('Discord notification sent successfully')
        else:
            print(f'Discord notification failed: {response.status_code}')
    except Exception as e:
        print(f'Failed to send Discord notification: {e}')

def parse_snyk_results():
    results = {
        'high': 0,
        'medium': 0,
        'low': 0,
        'total': 0
    }

    if os.path.exists('snyk-results/dependencies.json'):
        try:
            with open('snyk-results/dependencies.json', 'r') as f:
                data = json.load(f)
                if 'vulnerabilities' in data:
                    for vuln in data['vulnerabilities']:
                        severity = vuln.get('severity', 'low').lower()
                        if severity in results:
                            results[severity] += 1
                        results['total'] += 1
        except:
            pass

    if os.path.exists('snyk-results/code-scan.json'):
        try:
            with open('snyk-results/code-scan.json', 'r') as f:
                content = f.read()
                for line in content.strip().split('\n'):
                    if line.strip():
                        try:
                            data = json.loads(line)
                            if 'runs' in data:
                                for run in data['runs']:
                                    if 'results' in run:
                                        for result in run['results']:
                                            level = result.get('level', 'note')
                                            if level == 'error':
                                                results['high'] += 1
                                            elif level == 'warning':
                                                results['medium'] += 1
                                            else:
                                                results['low'] += 1
                                            results['total'] += 1
                        except:
                            continue
        except:
            pass

    return results

results = parse_snyk_results()
branch = os.getenv('BRANCH_NAME', 'unknown')
build_number = os.getenv('BUILD_NUMBER', '0')
timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

status = 'No Issues' if results['total'] == 0 else 'Issues Found'

message = f'''**Snyk Security Scan Report**
Branch: {branch}
Build: #{build_number}
Time: {timestamp}

Vulnerabilities Found:
High: {results['high']}
Medium: {results['medium']}
Low: {results['low']}
Total: {results['total']}

Status: {status}
'''

send_discord_notification(message)

with open('snyk-results/summary.txt', 'w') as f:
    f.write(f'High: {results[\"high\"]}\\n')
    f.write(f'Medium: {results[\"medium\"]}\\n')
    f.write(f'Low: {results[\"low\"]}\\n')
    f.write(f'Total: {results[\"total\"]}\\n')

print(f'Security scan completed. Total vulnerabilities: {results[\"total\"]}')
"
              '''

              def summary = readFile('snyk-results/summary.txt')
              def totalVulns = summary.readLines().find { it.startsWith('Total:') }?.split(':')[1]?.trim()?.toInteger() ?: 0

              if (totalVulns > 0) {
                echo "Security scan found ${totalVulns} vulnerabilities"
                currentBuild.result = 'UNSTABLE'
              } else {
                echo "Security scan completed successfully - no vulnerabilities found"
              }

            } catch (Exception e) {
              echo "Snyk scan failed: ${e.getMessage()}"
              currentBuild.result = 'UNSTABLE'
            }
          }
        }
      }
    }

    stage('SonarQube Analysis') {
      when {
        environment name: 'HAS_GO_CHANGES', value: 'true'
      }
      steps {
        withCredentials([string(credentialsId: 'sonar-token', variable: 'SONAR_TOKEN')]) {
          sh '''
            echo "=== Running SonarQube Analysis ==="
            echo "Java version: $($JAVA_HOME/bin/java -version 2>&1 | head -1)"

            $JAVA_HOME/bin/java -jar /opt/sonar-scanner/lib/sonar-scanner-cli-*.jar \
              -Dsonar.projectKey=gitea \
              -Dsonar.sources=. \
              -Dsonar.host.url=$SONAR_HOST_URL \
              -Dsonar.login=$SONAR_TOKEN \
              -Dsonar.inclusions=$(cat changed-go-files.txt | tr '\\n' ',' | sed 's/,$//')
          '''
        }
      }
    }

    stage('Quality Gate') {
      when {
        environment name: 'HAS_GO_CHANGES', value: 'true'
      }
      steps {
        script {
          echo "Waiting for Quality Gate result"

          def reportTaskFile = '.scannerwork/report-task.txt'
          if (!fileExists(reportTaskFile)) {
            error("SonarQube report-task.txt not found. Analysis might have failed.")
          }

          def taskUrl = sh(script: "grep 'ceTaskUrl=' ${reportTaskFile} | cut -d'=' -f2-", returnStdout: true).trim()
          if (!taskUrl) {
            error("Could not extract task URL from SonarQube report.")
          }

          echo "Task URL: ${taskUrl}"

          timeout(time: 5, unit: 'MINUTES') {
            waitUntil {
              script {
                withCredentials([string(credentialsId: 'sonar-token', variable: 'SONAR_TOKEN')]) {
                  def taskStatus = sh(script: """
                    curl -s -u \$SONAR_TOKEN: '${taskUrl}' | grep -o '"status":"[^"]*"' | cut -d'"' -f4 || echo 'UNKNOWN'
                  """, returnStdout: true).trim()

                  echo "Task status: ${taskStatus}"

                  if (taskStatus == 'SUCCESS') {
                    return true
                  } else if (taskStatus == 'FAILED' || taskStatus == 'CANCELLED') {
                    error("SonarQube analysis failed with status: ${taskStatus}")
                  }

                  sleep(10)
                  return false
                }
              }
            }
          }

          withCredentials([string(credentialsId: 'sonar-token', variable: 'SONAR_TOKEN')]) {
            def analysisId = sh(script: """
              curl -s -u \$SONAR_TOKEN: '${taskUrl}' | grep -o '"analysisId":"[^"]*"' | cut -d'"' -f4
            """, returnStdout: true).trim()

            if (!analysisId) {
              error("Could not extract analysis ID from SonarQube task.")
            }

            echo "Analysis ID: ${analysisId}"

            def qualityGateUrl = "${SONAR_HOST_URL}/api/qualitygates/project_status?analysisId=${analysisId}"
            def qualityGateResult = sh(script: """
              curl -s -u \$SONAR_TOKEN: '${qualityGateUrl}' | grep -o '"status":"[^"]*"' | cut -d'"' -f4 | head -1
            """, returnStdout: true).trim()

            echo "Quality Gate status: ${qualityGateResult}"

            if (qualityGateResult == 'ERROR') {
              def details = sh(script: """
                curl -s -u \$SONAR_TOKEN: '${qualityGateUrl}'
              """, returnStdout: true).trim()

              echo "Quality Gate failed"
              currentBuild.result = 'UNSTABLE'
              error("Quality Gate failed. Check SonarQube for details")
            } else if (qualityGateResult == 'OK') {
              echo "Quality Gate passed"
            } else {
              echo "Quality Gate status: ${qualityGateResult}"
            }
          }
        }
      }
    }

    stage('Archive Reports') {
      when {
        anyOf {
          environment name: 'HAS_GO_CHANGES', value: 'true'
          environment name: 'HAS_FILE_CHANGES', value: 'true'
        }
      }
      steps {
        sh '''
          mkdir -p artifacts

          if [ -f .scannerwork/report-task.txt ]; then
            cp .scannerwork/report-task.txt artifacts/
            echo "SonarQube Dashboard: http://localhost:9000/projects" > artifacts/sonar-dashboard-link.txt
          fi

          if [ -d snyk-results ]; then
            cp -r snyk-results artifacts/
            echo "Snyk scan results archived" > artifacts/snyk-scan-complete.txt
          fi

          echo "=== Security and Quality Report ===" > artifacts/combined-report.txt
          echo "Timestamp: $(date)" >> artifacts/combined-report.txt
          echo "Branch: ${BRANCH_NAME}" >> artifacts/combined-report.txt
          echo "Build: ${BUILD_NUMBER}" >> artifacts/combined-report.txt
          echo "" >> artifacts/combined-report.txt

          if [ -f snyk-results/summary.txt ]; then
            echo "=== Security Scan Results ===" >> artifacts/combined-report.txt
            cat snyk-results/summary.txt >> artifacts/combined-report.txt
            echo "" >> artifacts/combined-report.txt
          fi
        '''
        archiveArtifacts artifacts: 'artifacts/**', fingerprint: true
      }
    }
  }

  post {
    always {
      script {
        def hasGoChanges = env.HAS_GO_CHANGES == 'true'
        def hasFileChanges = env.HAS_FILE_CHANGES == 'true'

        if (!hasGoChanges && !hasFileChanges) {
          echo "Pipeline completed: No relevant changes detected"
        } else {
          echo "Pipeline completed: Scanned ${hasGoChanges ? 'Go files' : ''} ${hasFileChanges ? 'and security files' : ''}"
        }
      }
    }
    failure {
      script {
        echo "Pipeline failed during analysis"
        if (env.HAS_GO_CHANGES == 'true') {
          echo "Check SonarQube dashboard: ${SONAR_HOST_URL}/dashboard?id=gitea"
        }
        if (env.HAS_FILE_CHANGES == 'true') {
          echo "Check Snyk results in build artifacts"
        }
      }
    }
  }
}
