pipeline {
  agent {
    label 'docker-agent'
  }

  environment {
    SONAR_HOST_URL = 'http://sonarqube:9000'
    SONAR_SCANNER_OPTS = "-Xmx512m"
    JAVA_HOME = '/opt/java/openjdk'
    QUALITY_GATE_TIMEOUT = '10'
  }

  options {
    skipDefaultCheckout true
    timeout(time: 30, unit: 'MINUTES')
    buildDiscarder(logRotator(numToKeepStr: '10'))
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
        script {
          echo "Detected branch: ${env.BRANCH_NAME}"
          if (env.BRANCH_NAME != 'dev') {
            currentBuild.result = 'NOT_BUILT'
            error("Skipping analysis: not running on 'dev' branch.")
          }
        }
      }
    }

    stage('Detect .go changes compared to main') {
      steps {
        script {
          try {
            sh "git fetch origin main"
          } catch (Exception e) {
            echo "Warning: Could not fetch main branch: ${e.getMessage()}"
            echo "Proceeding with analysis of all .go files"
            env.HAS_GO_CHANGES = "true"
            return
          }

          def changed = sh(script: '''
            git diff --name-only origin/main...HEAD | grep '\\.go$' || true
          ''', returnStdout: true).trim()

          if (changed) {
            writeFile file: 'changed-go-files.txt', text: changed
            echo "Detected changed .go files:\n${changed}"
            env.HAS_GO_CHANGES = "true"
          } else {
            echo "No .go files changed. Aborting analysis."
            currentBuild.result = 'NOT_BUILT'
            error("No .go changes to analyze.")
          }
        }
      }
    }

    stage('Validate Go Files') {
      when {
        environment name: 'HAS_GO_CHANGES', value: 'true'
      }
      steps {
        script {
          echo "Validating Go Files"

          def goVersion = sh(script: 'which go && go version || echo "Go not found"', returnStdout: true).trim()
          echo "Go status: ${goVersion}"

          if (goVersion.contains('go version')) {
            try {
              sh '''
                echo "Running go vet on changed files"
                while IFS= read -r file; do
                  if [ -f "$file" ]; then
                    echo "Checking: $file"
                    go vet "$file" || echo "Warning: go vet failed for $file"
                  fi
                done < changed-go-files.txt
              '''
            } catch (Exception e) {
              echo "Warning: Go validation failed: ${e.getMessage()}"
            }
          } else {
            echo "Go not available, skipping syntax validation"
          }
        }
      }
    }

    stage('SonarQube Analysis') {
      when {
        environment name: 'HAS_GO_CHANGES', value: 'true'
      }
      steps {
        withCredentials([string(credentialsId: 'sonar-token', variable: 'SONAR_TOKEN')]) {
          script {
            try {
              sh '''
                echo "Running SonarQube Analysis"
                echo "Java version: $($JAVA_HOME/bin/java -version 2>&1 | head -1)"
                echo "SonarQube URL: $SONAR_HOST_URL"

                if [ -f changed-go-files.txt ] && [ -s changed-go-files.txt ]; then
                  INCLUSIONS=$(cat changed-go-files.txt | tr '\\n' ',' | sed 's/,$//')
                  echo "Analyzing files: $INCLUSIONS"
                else
                  echo "No specific files to analyze, analyzing all Go files"
                  INCLUSIONS="**/*.go"
                fi

                $JAVA_HOME/bin/java -jar /opt/sonar-scanner/lib/sonar-scanner-cli-*.jar \
                  -Dsonar.projectKey=gitea \
                  -Dsonar.sources=. \
                  -Dsonar.host.url=$SONAR_HOST_URL \
                  -Dsonar.login=$SONAR_TOKEN \
                  -Dsonar.inclusions="$INCLUSIONS" \
                  -Dsonar.go.coverage.reportPaths=coverage.out \
                  -Dsonar.exclusions="**/*_test.go,**/vendor/**,**/testdata/**"
              '''
            } catch (Exception e) {
              echo "SonarQube analysis failed: ${e.getMessage()}"
              currentBuild.result = 'UNSTABLE'
              throw e
            }
          }
        }
      }
    }

d as UNSTABLE due to Quality Gate timeout"
          } catch (Exception e) {
            echo "Quality Gate check failed: ${e.getMessage()}"
            currentBuild.result = 'UNSTABLE'
            echo "Build marked as UNSTABLE due to Quality Gate error"
          }
        }
      }
    }

    stage('Archive Sonar Report') {
      steps {
        script {
          try {
            sh '''
              mkdir -p artifacts

              if [ -f .scannerwork/report-task.txt ]; then
                cp .scannerwork/report-task.txt artifacts/
                echo "SonarQube report archived"
              else
                echo 'No SonarQube report generated.' > artifacts/no-sonar-report.txt
              fi

              if [ -f changed-go-files.txt ]; then
                cp changed-go-files.txt artifacts/
                echo "Changed files list archived"
              fi

              cat > artifacts/build-summary.txt << EOF
Build Information:
- Branch: ${env.BRANCH_NAME}
- Build Number: ${env.BUILD_NUMBER}
- Build Result: ${currentBuild.result ?: 'SUCCESS'}
- Timestamp: $(date)
- Go Changes Detected: ${env.HAS_GO_CHANGES ?: 'false'}
EOF
            '''

            archiveArtifacts artifacts: 'artifacts/**', fingerprint: true, allowEmptyArchive: true

          } catch (Exception e) {
            echo "Warning: Failed to archive artifacts: ${e.getMessage()}"
          }
        }
      }
    }
  }

  post {
    always {
      script {
        echo "Pipeline completed"
        echo "Final build result: ${currentBuild.result ?: 'SUCCESS'}"

        try {
          sh '''
            rm -f changed-go-files.txt
            rm -rf .scannerwork
          '''
        } catch (Exception e) {
          echo "Warning: Cleanup failed: ${e.getMessage()}"
        }
      }
    }

    success {
      echo "Pipeline completed successfully"
    }

    unstable {
      echo "Pipeline completed with warnings"
    }

    failure {
      echo "Pipeline failed"
    }

    cleanup {
      script {
        echo "Performing final cleanup"
      }
    }
  }
}
